<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code on Let&#39;s see what happens.</title>
    <link>https://sowcow.github.io/blog/tags/code/</link>
    <description>Recent content in code on Let&#39;s see what happens.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Feb 2020 18:36:45 +0500</lastBuildDate><atom:link href="https://sowcow.github.io/blog/tags/code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>January 2020</title>
      <link>https://sowcow.github.io/blog/posts/january-2020/</link>
      <pubDate>Sat, 01 Feb 2020 18:36:45 +0500</pubDate>
      
      <guid>https://sowcow.github.io/blog/posts/january-2020/</guid>
      <description>I almost stopped reading stuff so I didn&amp;rsquo;t write about anything interesting.
Although I have started listening to Chesterton&amp;rsquo;s Orthodoxy and I have given couple of small attempts to continue/restart reading Droyzen and Livy. I&amp;rsquo;m not doing it methodically and I&amp;rsquo;m not really in control of personal time now.
So I decided to write about what I have in mind to address that.
First there is an app idea that I develop when I feel like and then I move to something else.</description>
    </item>
    
    <item>
      <title>Tar Pit</title>
      <link>https://sowcow.github.io/blog/posts/tar-pit/</link>
      <pubDate>Tue, 20 Aug 2019 14:27:22 +0500</pubDate>
      
      <guid>https://sowcow.github.io/blog/posts/tar-pit/</guid>
      <description>I decided to write short summary and some ideas after reading &amp;ldquo;Out of the Tar Pit&amp;rdquo;.
Summary It looks like a theoretical high level paper about comlexity in large codebases.
The main point can be statend in the form: eliminate stuff/separate certain parts of the system to reduce power/ability to introduce accedintal complexity.
What is being separated: essential state, essential logic, control.
Also proposed ways to implement these parts:
state - relaitons logic - pure functions My Thoughts I am pretty convinced that relations are the way to go for the essential state.</description>
    </item>
    
    <item>
      <title>Random Code Thoughts</title>
      <link>https://sowcow.github.io/blog/posts/random-code-thoughts/</link>
      <pubDate>Tue, 06 Aug 2019 17:31:40 +0500</pubDate>
      
      <guid>https://sowcow.github.io/blog/posts/random-code-thoughts/</guid>
      <description>So I decided to put some thoughts about my coding here. There are three of them.
Copy-pasting This is one of my time wasters. I have this expectation that copy-pasted block should just work. But then there are little details that I miss that require a debugging session later.
Copy pasting by itself is not that evil. It can be avoided by additional abstractions. But you don&amp;rsquo;t want to commit to any random abstraction either.</description>
    </item>
    
    <item>
      <title>Real Abstractions</title>
      <link>https://sowcow.github.io/blog/posts/real-abstractions/</link>
      <pubDate>Sat, 29 Jun 2019 11:41:48 +0500</pubDate>
      
      <guid>https://sowcow.github.io/blog/posts/real-abstractions/</guid>
      <description>Abstractions are real.
Brains work with them.
And you can&amp;rsquo;t ignore what goes into your brain.
Things you can&amp;rsquo;t ignore are real for you.
Reality of production is reflected in the product.
Well. That was a tricky way to state that in the ideal world code quality is measured by the quality of abstractions.</description>
    </item>
    
    <item>
      <title>Intellectual Toys</title>
      <link>https://sowcow.github.io/blog/posts/intellectual-toys/</link>
      <pubDate>Thu, 20 Jun 2019 08:09:06 +0500</pubDate>
      
      <guid>https://sowcow.github.io/blog/posts/intellectual-toys/</guid>
      <description>I want to write an argument that there is a kind of people who like intellectual toys in certain area.
Earlier they found theology to be interesting.
Later such people were playing with philosophies, ideologies like communism.
And now such people may be writing code.
So people who are into religious fundamentalism or communism should definetly try coding.
Unfortunately in code you cannot use verbal tricks or force. But the good part is that you are not subject to the constrains of the real world either.</description>
    </item>
    
    <item>
      <title>Unconstrained Code</title>
      <link>https://sowcow.github.io/blog/posts/unconstrained-code/</link>
      <pubDate>Fri, 07 Jun 2019 09:05:18 +0500</pubDate>
      
      <guid>https://sowcow.github.io/blog/posts/unconstrained-code/</guid>
      <description>I was looking at what I am doing wrong with my personal projects recently. And I think that part of the problem is this unconstrained approach.
So there is the propensity in people to be blindly optimistic about something. I found mine to be interfering with the code.
So I gotta learn some good constraints.
I&amp;rsquo;ll try some very directed and formal approach with explicit principles and compromises.</description>
    </item>
    
    <item>
      <title>Complexity Order</title>
      <link>https://sowcow.github.io/blog/posts/complexity-order/</link>
      <pubDate>Fri, 24 May 2019 09:47:54 +0500</pubDate>
      
      <guid>https://sowcow.github.io/blog/posts/complexity-order/</guid>
      <description>The title may be ambiguous/misleading. And chances are the idea is old.
The idea is that you add complexity in the right order. I think this is the real idea behind KISS/YAGNI/etc..
For me the right/wrong here is intuitive. I need to return to it later.</description>
    </item>
    
  </channel>
</rss>
